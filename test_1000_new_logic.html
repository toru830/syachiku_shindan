<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1000回テスト - 新ロジック</title>
</head>
<body>
    <h1>1000回テスト結果（新ロジック）</h1>
    <div id="results"></div>

    <script>
        // === 固定：タイプキーと名称（順番は絶対に変更しない） ===
        const TYPE_NAME = {
          ELITE: "生粋の社畜",          // rare
          BURNOUT: "限界突破社畜",
          STOIC: "無敗の職人社畜",
          LONE: "孤高の成果主義社畜",
          KIND: "心優しき社畜",
          SENSITIVE: "誠実な観察社員",
          TEAM: "共創リーダー社員",
          PACE: "マイペース社員",
          YURUFUWA: "ゆるふわ社畜",
          HIDDEN: "隠れ疲労社畜",
          NICE: "お人好し社員",
          REAL: "現実派社員",
          FAMILY: "家庭が大事社員",
          LWB: "バランサー社員",
          ABLE: "成果最適化社畜",
          FREE: "自由人"                // rare
        };

        // 非レア14タイプ（この順番を絶対に変えない）
        const NON_RARE_KEYS = [
          "BURNOUT","STOIC","LONE","KIND","SENSITIVE","TEAM","PACE",
          "YURUFUWA","HIDDEN","NICE","REAL","FAMILY","LWB","ABLE"
        ];

        // === 決定性維持用のSALT（将来変更時は新SALTを付与して過去互換を維持） ===
        const SALT = "syachiku-v1.0.0-20251019";

        // === FNV-1a 32bit 決定的ハッシュ ===
        function hash32(str){
          let h = 2166136261 >>> 0;
          for(let i=0;i<str.length;i++){
            h ^= str.charCodeAt(i);
            h = Math.imul(h, 16777619) >>> 0;
          }
          return h >>> 0;
        }

        // === レア判定（極端回答のみ） ===
        // 閾値は必要に応じて微調整可：HIGH=85 / LOW=15 / hiCount=12 / loCount=12
        function pickRare(normalizedScores, answers){
          const {dedication:d, sacrifice:s, stress:r, relationship:h} = normalizedScores;
          const HIGH = 85, LOW = 15, HI_ANS = 5, LO_ANS = 1, HI_CNT = 12, LO_CNT = 12;

          const cntGE = (v)=>answers.reduce((a,x)=>a+(x>=v),0);
          const cntLE = (v)=>answers.reduce((a,x)=>a+(x<=v),0);

          const allHigh = (d>=HIGH && s>=HIGH && r>=HIGH && h>=HIGH) || (cntGE(HI_ANS) >= HI_CNT);
          if(allHigh) return { key:"ELITE", name: TYPE_NAME.ELITE };

          const allLow = (d<=LOW && s<=LOW && r<=LOW && h<=LOW) || (cntLE(LO_ANS) >= LO_CNT);
          if(allLow) return { key:"FREE", name: TYPE_NAME.FREE };

          return null;
        }

        // === 回答配列から決定的に非レア14タイプを均等割り当て ===
        function pickNonRareDeterministic(answers, normalizedScores){
          // できるだけ"回答の生配列"を使う（同じ回答→同じ結果）
          let sig = "A|" + answers.join(",");
          // 念のためスコアも混ぜる（0..100整数に丸め）
          const ns = normalizedScores;
          sig += `|X|${Math.round(ns.dedication)}|${Math.round(ns.sacrifice)}|${Math.round(ns.stress)}|${Math.round(ns.relationship)}`;

          const h = hash32(SALT + "|" + sig);
          const idx = h % NON_RARE_KEYS.length; // ★ 14 等分（構造的に均等）
          const key = NON_RARE_KEYS[idx];
          return { key, name: TYPE_NAME[key] };
        }

        // === 公開インターフェース ===
        function getResultType(normalizedScores, answers){
          // 1) レア判定（極端回答でのみ発火）
          const rare = pickRare(normalizedScores, answers);
          if(rare) return rare;

          // 2) 非レアは14等分の決定的バケツで配分
          return pickNonRareDeterministic(answers, normalizedScores);
        }

        // 実際のサイトと同じスコア計算（簡略版）
        function computeAxes(answers) {
            const scores = { dedication: 0, sacrifice: 0, stress: 0, relationship: 0 };
            
            // 簡略化された質問データ（15問分）
            const questions = [
                { axes: { dedication: 1, sacrifice: 1, stress: 0.5, relationship: 0 } },
                { axes: { dedication: 0.8, sacrifice: 1, stress: 0, relationship: 0 } },
                { axes: { dedication: 0.7, sacrifice: 0.6, stress: 0, relationship: 1 } },
                { axes: { dedication: 0.9, sacrifice: 1, stress: 0.7, relationship: 0 } },
                { axes: { dedication: 0.3, sacrifice: 0.7, stress: 0, relationship: 1 } },
                { axes: { dedication: 0.5, sacrifice: 0.6, stress: 0, relationship: 1 } },
                { axes: { dedication: 0.8, sacrifice: 0.8, stress: 0.5, relationship: 0.3 } },
                { axes: { dedication: 0.7, sacrifice: 0.5, stress: 1, relationship: 0 } },
                { axes: { dedication: 1, sacrifice: 1, stress: 0, relationship: 0 } },
                { axes: { dedication: 0.9, sacrifice: 1, stress: 0, relationship: 0.5 } },
                { axes: { dedication: 1, sacrifice: 0, stress: 0, relationship: 0 }, reverse: true },
                { axes: { dedication: 0.8, sacrifice: 0, stress: 0, relationship: 0 }, reverse: true },
                { axes: { dedication: 0.7, sacrifice: 0, stress: 0, relationship: 0.5 }, reverse: true },
                { axes: { dedication: 0.6, sacrifice: 0, stress: 0.3, relationship: 0 }, reverse: true },
                { axes: { dedication: 0.9, sacrifice: 0, stress: 0, relationship: 0 }, reverse: true }
            ];
            
            questions.forEach((q, i) => {
                const value = answers[i];
                const multiplier = q.reverse ? -1 : 1;
                scores.dedication += value * q.axes.dedication * multiplier;
                scores.sacrifice += value * q.axes.sacrifice * multiplier;
                scores.stress += value * q.axes.stress * multiplier;
                scores.relationship += value * q.axes.relationship * multiplier;
            });
            
            // 正規化（簡略版）
            const maxScore = 75; // 概算の最大値
            const minScore = -25; // 概算の最小値
            
            return {
                dedication: Math.max(0, Math.min(100, ((scores.dedication - minScore) / (maxScore - minScore)) * 100)),
                sacrifice: Math.max(0, Math.min(100, ((scores.sacrifice - minScore) / (maxScore - minScore)) * 100)),
                stress: Math.max(0, Math.min(100, ((scores.stress - minScore) / (maxScore - minScore)) * 100)),
                relationship: Math.max(0, Math.min(100, ((scores.relationship - minScore) / (maxScore - minScore)) * 100))
            };
        }

        // ランダムな回答を生成
        function generateRandomAnswers() {
            const answers = [];
            for (let i = 0; i < 15; i++) {
                answers.push(Math.floor(Math.random() * 6)); // 0-5のランダム値
            }
            return answers;
        }

        // 1000回テスト実行
        function runTest() {
            const results = {};
            for (let i = 0; i < 1000; i++) {
                const answers = generateRandomAnswers();
                const scores = computeAxes(answers);
                const resultType = getResultType(scores, answers);
                
                if (results[resultType.name]) {
                    results[resultType.name]++;
                } else {
                    results[resultType.name] = 1;
                }
            }

            // 結果を表示
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<h2>=== 1000回テスト結果（新ロジック） ===</h2>';
            
            Object.entries(results).sort((a, b) => b[1] - a[1]).forEach(([name, count]) => {
                const percentage = (count / 1000 * 100).toFixed(1);
                resultsDiv.innerHTML += `<p>${name}: ${count}回 (${percentage}%)</p>`;
            });
        }

        // ページ読み込み時にテスト実行
        window.onload = runTest;
    </script>
</body>
</html>