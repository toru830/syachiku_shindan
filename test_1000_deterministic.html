<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>1000回テスト - 決定的ロジック</title>
</head>
<body>
  <h1>1000回テスト実行中（決定的ロジック）...</h1>
  <div id="results"></div>

<script>
// 現在のscript.jsから診断ロジックをコピー
// 質問データ
const questions = [
    "残業は当たり前だと思いますか？",
    "休日も仕事のことを考えてしまいますか？",
    "会社の利益を自分の利益より優先しますか？",
    "仕事で成果を出すことが人生の目標ですか？",
    "有給休暇を取ることに罪悪感を感じますか？",
    "家族より仕事を優先してしまいますか？",
    "体調が悪くても仕事を休めませんか？",
    "プライベートの時間を仕事に使いますか？",
    "自分の健康より会社のことを考えますか？",
    "友人との約束より仕事を優先しますか？",
    "プレッシャーを感じても頑張れますか？",
    "困難な状況でも諦めませんか？",
    "ストレスを感じても仕事を続けられますか？",
    "同僚との関係を大切にしますか？",
    "チームワークを重視しますか？"
];

// === タイプ定義（16種類・新名称仕様） ===
const TYPES = {
  ELITE: { key:"ELITE", name:"生粋の社畜", icon:"🔥",
    desc:"全軸が非常に高い究極の献身者。仕事と一体化し、成果を使命とする存在。", 
    rare:true, tags:["究極の献身","燃え尽き注意"],
    centroid:{d:95,s:95,r:95,h:95} },

  BURNOUT: { key:"BURNOUT", name:"限界突破社畜", icon:"⚠️",
    desc:"献身・犠牲が高く、耐性と人間関係が低い。限界まで挑み続ける頑張り屋タイプ。",
    centroid:{d:80,s:80,r:20,h:20}, tags:["過負荷","要休息"] },

  STOIC: { key:"STOIC", name:"無敗の職人社畜", icon:"🥇",
    desc:"高献身・高犠牲・高耐性。黙々と成果を積み上げるプロ意識の持ち主。",
    centroid:{d:85,s:75,r:85,h:35}, tags:["自己規律","粘り強さ"] },

  LONE: { key:"LONE", name:"孤高の成果主義社畜", icon:"🐺",
    desc:"献身・犠牲・耐性は高く、人間関係は控えめ。結果に全てを賭ける孤高の戦士。",
    centroid:{d:85,s:75,r:85,h:15}, tags:["独立独歩","集中力"] },

  KIND: { key:"KIND", name:"心優しき社畜", icon:"💐",
    desc:"高献身で人間関係を大切にする温厚タイプ。チームを支える縁の下の力持ち。",
    centroid:{d:75,s:25,r:25,h:85}, tags:["思いやり","共感"] },

  SENSITIVE: { key:"SENSITIVE", name:"誠実な観察社員", icon:"🌿",
    desc:"献身は高いが犠牲と耐性は低い。誠実で丁寧、感受性豊かな観察者。",
    centroid:{d:75,s:25,r:25,h:25}, tags:["慎重","誠実"] },

  TEAM: { key:"TEAM", name:"共創リーダー社員", icon:"🤝",
    desc:"高献身・高耐性・人間関係高。協働で成果を生み、周囲を導くタイプ。",
    centroid:{d:70,s:40,r:80,h:85}, tags:["協調","信頼"] },

  PACE: { key:"PACE", name:"マイペース社員", icon:"🧭",
    desc:"献身・耐性が高いが関係性は控えめ。自律して淡々と結果を出す。",
    centroid:{d:70,s:35,r:80,h:35}, tags:["自律","安定"] },

  YURUFUWA: { key:"YURUFUWA", name:"ゆるふわ社畜", icon:"🫧",
    desc:"献身は低いが犠牲が高く、人のために動くやさしき奉仕者。自己犠牲に注意。",
    centroid:{d:25,s:80,r:25,h:85}, tags:["優しさ","自己犠牲"] },

  HIDDEN: { key:"HIDDEN", name:"隠れ疲労社畜", icon:"🌧️",
    desc:"バランス型だが耐性が低い。無自覚に疲れをためがちな頑張り屋。",
    centroid:{d:45,s:45,r:20,h:45}, tags:["回復重視","ストレス管理"] },

  NICE: { key:"NICE", name:"お人好し社員", icon:"😊",
    desc:"全体中庸・人間関係が高い。潤滑油として場を整え、支援に長ける。",
    centroid:{d:45,s:45,r:55,h:88}, tags:["調整役","優しさ"] },

  REAL: { key:"REAL", name:"現実派社員", icon:"🧱",
    desc:"全体中庸・人間関係控えめ。合理的・実務的で堅実なリアリスト。",
    centroid:{d:55,s:55,r:55,h:15}, tags:["堅実","実務力"] },

  FAMILY: { key:"FAMILY", name:"家庭が大事社員", icon:"🏡",
    desc:"低献身・低犠牲・人間関係高。家族や私生活を大切にするバランス型。",
    centroid:{d:25,s:25,r:55,h:85}, tags:["安定","ライフ重視"] },

  LWB: { key:"LWB", name:"バランサー社員", icon:"⚖️",
    desc:"中庸で調和志向。仕事と生活の両立を重視するスマートワーカー。",
    centroid:{d:58,s:32,r:55,h:55}, tags:["調和","柔軟性"] },

  ABLE: { key:"ABLE", name:"成果最適化社畜", icon:"🚀",
    desc:"高献身・中犠牲・高耐性。戦略的に動く結果重視タイプ。",
    centroid:{d:78,s:55,r:85,h:55}, tags:["戦略性","効率重視"] },

  FREE: { key:"FREE", name:"自由人", icon:"🕊️",
    desc:"全軸が低い自由奔放タイプ。自分の感性を軸に生きるクリエイター気質。",
    rare:true, tags:["自由","創造性"],
    centroid:{d:5,s:5,r:5,h:5} },
};

// ===== 同一回答→同一結果を保証するためのユーティリティ =====
function hash32(str){
  // 簡易ハッシュ（同一入力に対して決定的）
  let h = 2166136261 >>> 0;
  for (let i = 0; i < str.length; i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619) >>> 0;
  }
  return h >>> 0;
}

// 決定的Gumbel(0,1) 生成：同じ seed → 同じノイズ
function gumbelDet(seed){
  // 0< u <1 の決定的一様乱数を seed から作る
  let x = seed >>> 0;
  x ^= x << 13; x >>>= 0;
  x ^= x >>> 17; x >>>= 0;
  x ^= x << 5;  x >>>= 0;
  const u = ((x >>> 0) + 1) / 4294967297; // (0,1)に正規化（0と1を避ける）
  return -Math.log(-Math.log(u));
}

// 中央密集を少し崩す（必要なければ k=1.0 に）
function spreadAxes(ax){
  const k = 1.5; // 1.4〜1.8で調整可（UI非依存）
  const clamp = v => Math.max(0, Math.min(100, v));
  return {
    d: clamp(50 + (ax.d - 50) * k),
    s: clamp(50 + (ax.s - 50) * k),
    r: clamp(50 + (ax.r - 50) * k),
    h: clamp(50 + (ax.h - 50) * k),
  };
}

// ===== 均しつつ"決定的"に1タイプを選ぶ =====
const BALANCE_CFG = {
  sigma: 30,     // 距離→確率の丸め具合（20〜40）
  alpha: 0.45,   // 事前分布の効き具合（0=距離のみ, 1=事前のみ）
  tau:   0.30    // 決定的ノイズの強さ（0で完全決定論）※同一入力なら常に同一
};

// 目標分布（均等）— 必要ならレア5%などに変更可能
const TARGET_PRIORS = (() => {
  const pri = {};
  const keys = Object.keys(TYPES);
  keys.forEach(k => pri[k] = 1 / keys.length);
  return pri;
})();

function pickTypeBalancedDet(ax){
  const { sigma, alpha, tau } = BALANCE_CFG;
  const twoSig2 = 2 * sigma * sigma;

  // 回答ベクトルをシリアライズ（同一回答→同一シード）
  const sig = `${Math.round(ax.d)}|${Math.round(ax.s)}|${Math.round(ax.r)}|${Math.round(ax.h)}`;
  let best = null, bestScore = -Infinity;

  for (const t of Object.values(TYPES)){
    const c = t.centroid;
    const dist2 =
      (ax.d - c.d) * (ax.d - c.d) +
      (ax.s - c.s) * (ax.s - c.s) +
      (ax.r - c.r) * (ax.r - c.r) +
      (ax.h - c.h) * (ax.h - c.h);

    const like  = - dist2 / twoSig2;                    // 距離ベース
    const prior = Math.log(TARGET_PRIORS[t.key] || 1e-9); // 均等事前
    // タイプ別に異なる"決定的ノイズ"（同一回答・同タイプ→常に同じ）
    const seed  = hash32(sig + '::' + t.key);
    const gum   = gumbelDet(seed);
    const score = (1 - alpha) * like + alpha * prior + tau * gum;

    if (score > bestScore){ bestScore = score; best = t; }
  }
  return best;
}

// ===== レア判定（必要なら維持 / 無しでも可） =====
function rareCheck(ax){
  if (ax.d>=80 && ax.s>=80 && ax.r>=80 && ax.h>=80) return TYPES.ELITE;
  if (ax.d<=20 && ax.s<=20 && ax.r<=20 && ax.h<=20) return TYPES.FREE;
  return null;
}

// スコア計算関数（現在のscript.jsから）
function calculateScores(answers) {
    const dedication = (answers.slice(0, 5).reduce((a, b) => a + b, 0) / 5) * 20;
    const sacrifice = (answers.slice(5, 10).reduce((a, b) => a + b, 0) / 5) * 20;
    const stress = (answers.slice(10, 13).reduce((a, b) => a + b, 0) / 3) * 20;
    const relationship = (answers.slice(13, 15).reduce((a, b) => a + b, 0) / 2) * 20;
    
    return { dedication, sacrifice, stress, relationship };
}

// ===== 診断フロー（UIは既存のまま） =====
function getResultType(normalizedScores) {
    const ax0 = {
        d: normalizedScores.dedication,
        s: normalizedScores.sacrifice,
        r: normalizedScores.stress,
        h: normalizedScores.relationship
    };
    
    const ax = spreadAxes(ax0);     // 中央密集を少し拡散（不要なら ax0）
    
    console.log('=== 診断デバッグ情報 ===');
    console.log('診断スコア（元）:', ax0);
    console.log('診断スコア（拡散後）:', ax);
    
    // まずレアを決定的に判定→残りは決定的Gumbelで均しつつ選択
    const picked = rareCheck(ax) || pickTypeBalancedDet(ax);
    
    console.log('選択されたタイプ:', picked.name);
    console.log('=== 診断デバッグ終了 ===');
    
    return picked;
}

// ランダムな回答を生成
function generateRandomAnswers() {
    const answers = [];
    for (let i = 0; i < 15; i++) {
        answers.push(Math.floor(Math.random() * 6) + 1); // 1-6
    }
    return answers;
}

// 1000回テスト実行
function runTest() {
    const results = {};
    
    // 初期化
    Object.values(TYPES).forEach(type => {
        results[type.name] = 0;
    });
    
    console.log('1000回テスト開始（決定的ロジック）...');
    
    for (let i = 0; i < 1000; i++) {
        const answers = generateRandomAnswers();
        const scores = calculateScores(answers);
        const result = getResultType(scores);
        results[result.name]++;
        
        if (i % 100 === 0) {
            console.log(`${i}回完了`);
        }
    }
    
    console.log('1000回テスト完了！');
    
    // 結果を表示
    const resultsDiv = document.getElementById('results');
    resultsDiv.innerHTML = '<h2>1000回テスト結果（決定的ロジック）</h2>';
    
    const sortedResults = Object.entries(results)
        .sort((a, b) => b[1] - a[1]);
    
    let resultText = '';
    sortedResults.forEach(([name, count]) => {
        const percentage = (count / 1000 * 100).toFixed(1);
        const barWidth = (count / 1000 * 100).toFixed(1);
        resultText += `${name}: ${count}回 (${percentage}%)\n`;
        resultsDiv.innerHTML += `
            <div style="margin: 10px 0; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
                <strong>${name}</strong>: ${count}回 (${percentage}%)
                <div style="background: #f0f0f0; height: 20px; border-radius: 10px; margin-top: 5px;">
                    <div style="background: #4CAF50; height: 100%; width: ${barWidth}%; border-radius: 10px;"></div>
                </div>
            </div>
        `;
    });
    
    // コンソールにも出力
    console.log('\n=== 1000回テスト結果（決定的ロジック） ===');
    console.log(resultText);
    
    // 結果をアラートで表示
    alert('1000回テスト完了（決定的ロジック）！\n\n' + resultText);
    
    return results;
}

// ページ読み込み時にテスト実行
window.onload = runTest;
</script>
</body>
</html>
